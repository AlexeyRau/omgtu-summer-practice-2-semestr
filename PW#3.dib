#!meta

{"kernelInfo":{"defaultKernelName":"csharp","items":[{"aliases":[],"languageName":"csharp","name":"csharp"}]}}

#!markdown

# Практическая работа №1. Знакомство с потоками.

**Цель:** Познакомиться с возможностями класса System.Thread платформы .NET Framework.

**Результаты:** После выполнения работы Вы сможете:
1. Запускать длительные операции в отдельном потоке.
2. Завершать поток.
3. Дожидаться завершения выполнения потока. 


**Материалы для самостоятельного изучения**.
1. [Основы управления потоками](https://learn.microsoft.com/en-us/dotnet/standard/threading/managed-threading-basics)
2. [Использование потоков](https://learn.microsoft.com/en-us/dotnet/standard/threading/using-threads-and-threading)
3. [Примитив синхронизации Барьер](https://learn.microsoft.com/ru-ru/dotnet/standard/threading/barrier)
4. [Interlocked операции](https://learn.microsoft.com/en-us/dotnet/api/system.threading.interlocked?view=net-8.0)

## Задание.
Реализовать вычисление определенного интеграла методом трапеции в несколько потоков.

Отрезок, на котором происходит вычисление, разбивается на отрезки по количеству потоков. Для каждого отрезка значение 
интеграла считается в отдельном потоке, после завершения вычисоения полученный рельтаты суммирутся.

**Указание**.
1. Для суммирования результатов удобно воспользоваться разделяемой переменной, к которой будут прибалятся результаты вычисления прямо в самом потоке. Для синхронизации операций сложения лучше всего восользоваться [Interlocked операцией](https://learn.microsoft.com/en-us/dotnet/api/system.threading.interlocked?view=net-8.0).
2. Основная функция долна дождаться завершения всех потоков, которые вычисляют значение на отрезках, прежде чем возвратить результат. Для этого удобнее всего использовать Примитив синхронизации Барьер](https://learn.microsoft.com/ru-ru/dotnet/standard/threading/barrier).

#!csharp

using System.Threading;
//
// Вычисление определенного интеграла
//
class DefiniteIntegral
{
    //
    // a, b - границы отрезка, на котором происходит вычисление опредленного интеграла
    // function - функция, для которой вычисляется определнный интеграл
    // step - размер одного шага разбиения
    // threadsNumber - число потоков, которые используются для вычислений
    //
    public static double Solve(double a, double b, Func<double, double> function, double step, int threadsNumber)
    {
        // отсюда надо начинать реализацию задачи
        var barrier = new Barrier(threadsNumber + 1);
        object lockObject = new object();
        var countOfSegments = Math.Round((b - a) / step);
        var threadCountOfSegments = countOfSegments / threadsNumber;
        var totalSum = 0.0;
        bool remains = false;
        int j = 1;
        while (true)
        {
            if (threadCountOfSegments % 1 != 0 && threadsNumber != 0)
            {   
                threadCountOfSegments = (countOfSegments - j) / threadsNumber;
                j++;
                remains = true;
            }
            else
            {
                break;
            }
        }
        if (remains)
        {
            totalSum += 0.5 * (function(a + threadCountOfSegments * threadsNumber * step) + function(b));
            for (int i = 1; i < (countOfSegments - threadCountOfSegments * threadsNumber); i++)
            {
                totalSum += function(a + threadCountOfSegments * threadsNumber * step + i * step);
            }
        }
        for (int i = 0; i < threadsNumber; i++)
        {
            double start = a + i * threadCountOfSegments * step;
            double end = start + threadCountOfSegments * step;
            Thread thread = new Thread(() => Distribution(i - 1, start, end));
            thread.Start();
        }
        barrier.SignalAndWait();
        void Distribution(int threadNumber, double start, double end)
        {
            double localSum = 0.0;
            localSum = 0.5 * (function(a) + function(a + threadCountOfSegments * threadsNumber * step));
            for (int i = 1; i < threadCountOfSegments; i++)
            {
                localSum += function(start + i * step);
            }   
            lock (lockObject)
            {
                totalSum += localSum;
            }
            barrier.SignalAndWait();
            
        }
        totalSum *= step;
        return totalSum;
    }
}

#!csharp

class DefiniteIntegralNoThreads
{
public static double Solve(double a, double b, Func<double, double> function, double step) {
        
        var countOfSegments = (b - a) / step;
        double sum = 0.5 * (function(a) + function(b));
        for (int i = 1; i < countOfSegments; i++)
        {
            sum += function(a + i * step);
        }
        double res = step * sum;
        return res;
        
    }
}

#!csharp

using System.Diagnostics;
//Выбор оптимального шага
List<double> steps = new List<double>(){1e-1, 1e-2, 1e-3, 1e-4, 1e-5, 1e-6};
Stopwatch stopwatch = new Stopwatch();
foreach(double step in steps)
{
    stopwatch.Start();
    Assert.Equal(0, DefiniteIntegral.Solve(-100, 100, SIN, step, 10), 1e-4);
    stopwatch.Stop();
    var res = DefiniteIntegral.Solve(-100, 100, SIN, step, 5);
    Console.WriteLine($"Шаг: {stopwatch}, Время: {stopwatch.Elapsed}, Результат: {res}");
    stopwatch.Reset();
}
//Оптимальный шаг 1e-3

#!csharp

//Оптимальное число потоков
// Install the ScottPlot NuGet package
#r "nuget:ScottPlot, 5.0.36"

// Setup a custom formatter to display plots as images
using Microsoft.DotNet.Interactive.Formatting;
Formatter.Register(typeof(ScottPlot.Plot), (p, w) => 
    w.Write(((ScottPlot.Plot)p).GetImageHtml(600, 600)), HtmlFormatter.MimeType);
List<double> graphX = new List<double>();
List<double> graphY = new List<double>();
int optimalNumberThreads = 0;
var optimalTime = double.MaxValue;

// plot the data
ScottPlot.Plot plt = new();

for(int i = 0; i <= 10; i++)
{
    stopwatch.Start();
    var res = DefiniteIntegral.Solve(-100, 100, SIN, 1e-3, i);
    stopwatch.Stop();
    Console.WriteLine($"Потоков: {i}, Время: {stopwatch}, Результат: {res}");
    graphX.Add(stopwatch.ElapsedTicks*1e-4);
    graphY.Add(i);
    if(optimalTime > (stopwatch.ElapsedTicks*1e-4) && i != 0)
    {
        optimalTime = stopwatch.ElapsedTicks*1e-4;
        optimalNumberThreads = i;
    }
    stopwatch.Reset();
}
stopwatch.Start();
var res = DefiniteIntegralNoThreads.Solve(-100, 100, SIN, 1e-3);
stopwatch.Stop();
Console.WriteLine();
Console.WriteLine($"Без потоков: Время: {stopwatch.ElapsedTicks*1e-4}мс, Результат: {res}");
Console.WriteLine($"Оптимальное число потоков: {optimalNumberThreads}, Время: {optimalTime}мс");

Console.WriteLine($"Процентная разница: {((stopwatch.ElapsedTicks*1e-4-optimalTime)/(stopwatch.ElapsedTicks*1e-4))*100}%");
stopwatch.Reset();
plt.Add.Scatter(graphX, graphY);
plt

#!csharp

#r "nuget: xunit, 2.8.1"

using Xunit;

var X = (double x) => x;
var SIN = (double x) => Math.Sin(x);

Assert.Equal(0, DefiniteIntegral.Solve(-1, 1, X, 1e-4, 2), 1e-4);

Assert.Equal(0, DefiniteIntegral.Solve(-1, 1, SIN, 1e-5, 8), 1e-4);

Assert.Equal(50, DefiniteIntegral.Solve(0, 10, X, 1e-6, 8), 1e-5);

#!markdown

# Summary
Оптимальный шаг - 1e-3

Оптимальное количество потоков - 4

Разница в процентах - 56%
